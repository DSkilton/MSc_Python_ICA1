### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\base_api_service.py (Filename: base_api_service.py) ###

import requests
import time
import logging 

class BaseApiService:
    

    def __init__(self, base_url, max_retries=3, retry_delay=2):
        
        self.base_url = base_url
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.debug(f"BaseApiService initialized with base_url={base_url}, max_retries={max_retries}, retry_delay={retry_delay}")


    def _make_request(self, endpoint="", params=None):
        
        self.logger.debug(f"Attempting to make request to {self.base_url}/{endpoint} with params {params}")

        url = f"{self.base_url}/{endpoint}".strip("/")
        params = params or {}

        for attempt in range(1, self.max_retries + 1):
            try:
                self.logger.info(f"Attempt {attempt}: Requesting {url} with params {params}")
                response = requests.get(url, params=params)
                response.raise_for_status()
                self.logger.debug(f"Request succeeded on attempt {attempt}, Response: {response}")
                data = response.json()

                if not isinstance(data, dict) not in data:
                    self.logger.error(f"Invalid response structure from API: {type(data)}, {data}")
                    raise ValueError("Invalid response structure from API.")
                self.logger.debug(f"Request succeeded on attempt {attempt}")
                
                return data
            except requests.RequestException as e:
                self.logger.error(f"Attempt {attempt} failed: {e}")
                if attempt < self.max_retries:
                    time.sleep(self.retry_delay)
                else:
                    raise Exception(f"Failed to fetch data from {url} after {self.max_retries} attempts")
            except requests.exceptions.HTTPError as e:
                self.logger.error(f"HTTP error occurred: {e}")
                raise
            except requests.exceptions.RequestException as e:
                self.logger.error(f"Error in making request to {url}: {e}")
                raise


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\console_output_handler.py (Filename: console_output_handler.py) ###

import logging

class ConsoleOutputHandler:
    

    logger = logging.getLogger(__name__)

    @staticmethod
    def handle_console(results, result_title=None):
        
        ConsoleOutputHandler.logger.info(f"console_output_handler, handle_console results: {results[:10]}")
        ConsoleOutputHandler.logger.info(f"console_output_handler, handle_console results: {type(results)}")
        
        
        if isinstance(results, (int, float)):  
            ConsoleOutputHandler.display_single_result(result_title, results)
            return
        
        if not results or not isinstance(results, list) or not isinstance(results[0], dict):
            print("No valid data to display.")
            return

        
        headers = list(results[0].keys())
        widths = {header: max(len(header), max(len(str(row.get(header, ''))) for row in results)) for header in headers}

        
        header_line = " | ".join(f"{header:<{widths[header]}}" for header in headers)
        separator = "-+-".join("-" * widths[header] for header in headers)
        print(header_line)
        print(separator)

        
        for row in results:
            print(" | ".join(f"{str(row.get(header, '')):<{widths[header]}}" for header in headers))

    @staticmethod
    def display_table(results):
        
        if not results:
            print("No data available to display.")
            ConsoleOutputHandler.logger.warning("No data available to display.")
            return

        
        headers = results[0].keys()

        
        column_widths = {header: len(header) for header in headers}
        ConsoleOutputHandler.logger.debug(f"Initial column widths (headers): {column_widths}")

        for row in results:
            for header in headers:
                cell_value = str(row.get(header, ""))
                column_widths[header] = max(column_widths[header], len(cell_value))

        ConsoleOutputHandler.logger.debug(f"Final column widths (adjusted): {column_widths}")

        
        header_line = " | ".join(f"{header:<{column_widths[header]}}" for header in headers)
        separator_line = "-+-".join("-" * column_widths[header] for header in headers)

        print(header_line)
        print(separator_line)

        
        for row in results:
            row_line = " | ".join(
                f"{str(row.get(header, '')):<{column_widths[header]}}" for header in headers
            )
            print(row_line)

    @staticmethod
    def display_single_result(result_title, result):
        
        print(f"{result_title}: {result:.2f}")


    @staticmethod
    def display_monthly_avg_temperature(monthly_data):
        
        print(f"Monthly Average Temperature:")
        headers = ['Month', 'Average Temperature (°C)']
        
        widths = {
            'Month': len('Month'),
            'Average Temperature (°C)': len('Average Temperature (°C)')
        }
        for month, temp in monthly_data.items():
            widths['Month'] = max(widths['Month'], len(str(month)))
            widths['Average Temperature (°C)'] = max(widths['Average Temperature (°C)'], len(f"{temp:.2f}"))

        
        header_line = f"{'Month':<{widths['Month']}} | {'Average Temperature (°C)':<{widths['Average Temperature (°C)']}}"
        separator = f"{'-' * widths['Month']} +- {'-' * widths['Average Temperature (°C)']}"
        print(header_line)
        print(separator)

        
        for month, temp in monthly_data.items():
            print(f"{month:<{widths['Month']}} | {temp:.2f}".ljust(widths['Average Temperature (°C)']))


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\constants.py (Filename: constants.py) ###




START_OF_YEAR = "-01-01"
END_OF_YEAR = "-12-31"


SELECT_FROM = "SELECT * FROM "


DAILY_WEATHER_TBL = "daily_weather_entries"
COUNTRIES_TBL = "countries"
CITIES_TBL = "cities"


CITY = "city"
CITY_ID = "city_id"
COUNTRY_ID = "country_id"
PRECIP = "precipitation"
TEMP = "temperature"
DATE = "date"
MEAN_TEMP = "mean_temp"
YEAR = "year"


DISPLAY_CONSOLE = 1
DISPLAY_BAR_CHART = 2
DISPLAY_PIE_CHART = 3
DISPLAY_SCATTER_PLOT = 4
DISPLAY_LINE_CHART = 5


MENU_VIEW_COUNTRIES = 1
MENU_VIEW_CITIES = 2
MENU_AVG_TEMP = 3
MENU_7DAY_PRECIP = 4
MENU_MEAN_TEMP_CITY = 5
MENU_ANNUAL_PRECIP_CITY = 6
MENU_EXIT = 0


TITLE_COUNTRIES = "Countries"
TITLE_CITIES = "Cities"
TITLE_AVG_TEMP = "Average Temperature"
TITLE_7DAY_PRECIP = "Average Seven-Day Precipitation"
TITLE_MEAN_TEMP_CITY = "Mean Temperature by City"
TITLE_ANNUAL_PRECIP = "Annual Precipitation by Country"


X_LABEL_COUNTRIES = "Country Name"
X_LABEL_CITIES = "City Name"
X_LABEL_TEMPERATURE = "Temperature"
X_LABEL_PRECIPITATION = "Precipitation"
X_LABEL_YEAR = "Year"


Y_LABEL_COUNTRY_ID = "Country Id"
Y_LABEL_CITY_ID = "City Id"
Y_LABEL_TEMPERATURE = "Temperature (°C)"
Y_LABEL_PRECIPITATION = "Precipitation (mm)"

ATTEMPT = "attempt"
NAME = "name"
LATITUDE = "latitude"
LONGITUDE = "longitude"
COUNTRY = "country"
TIMEZONE = "timezone"

START_DATE = "start_date"
END_DATE = "end_date"
DAILY = "daily"

TEMPERATURE_2M_MAX = "temperature_2m_max"
TEMPERATURE_2M_MIN = "temperature_2m_min"
PRECIPITATION_SUM = "precipitation_sum"

ID = "id"

MONTH_NAMES = [
        "January", "February", "March", "April", "May", "June", "July", "August", 
        "September", "October", "November", "December"
]


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\database_initialiser.py (Filename: database_initialiser.py) ###

import threading
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from models import Base, Country, City, DailyWeatherEntry
import logging


logging.basicConfig(level=logging.INFO)
logging.getLogger('sqlalchemy.engine').setLevel(logging.DEBUG)
logger = logging.getLogger("db_initialiser")


DATABASE_URL = "sqlite:///CIS4044-N-SDI-OPENMETEO-PARTIAL.db"


engine = create_engine(DATABASE_URL, echo=True)


Session = sessionmaker(bind=engine)


def remove_duplicates(session, model):
    
    try:
        
        duplicates = []

        
        if model == Country:
            
            query = 
            duplicates = session.execute(query).fetchall()

        elif model == City:
            
            query = 
            duplicates = session.execute(query).fetchall()

        elif model == DailyWeatherEntry:
            
            query = 
            duplicates = session.execute(query).fetchall()

        
        for duplicate in duplicates:
            rowid = duplicate[-1]  
            
            condition = " AND ".join([f"{column} = :{column}" for column in duplicate[:-1]])
            
            session.execute(f"DELETE FROM {model.__tablename__} WHERE ROWID != {rowid} AND ({condition})",
                            {column: value for column, value in zip(duplicate[:-1], duplicate[:-1])})

        
        session.commit()
        logger.info(f"Duplicates removed for {model.__name__}")

    except SQLAlchemyError as e:
        session.rollback()
        logger.error(f"Error during duplicate removal for {model.__name__}: {e}")
        raise


def clean_duplicates_in_background():
    
    session = Session()

    try:
        
        logger.info("Starting background cleanup of duplicate rows...")
        models = [Country, City, DailyWeatherEntry]
        for model in models:
            threading.Thread(target=remove_duplicates, args=(session, model), daemon=True).start()

    except SQLAlchemyError as e:
        logger.error(f"Error during cleanup process: {e}")
    finally:
        session.close()


def initialise_database():
    
    try:
        logger.info("Creating database tables...")
        Base.metadata.create_all(engine)
        logger.info("Database initialised successfully.")

        
        clean_duplicates_in_background()

    except SQLAlchemyError as e:
        logger.error(f"Database initialisation failed: {e}")
        raise


if __name__ == "__main__":
    initialise_database()


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\database_manager.py (Filename: database_manager.py) ###

import logging
from sqlalchemy.orm import sessionmaker

class DatabaseManager:
    

    def __init__(self, engine):
        
        self.engine = engine
        self.session = sessionmaker(bind=self.engine)


    def get_session(self):
        
        return self.session()


    def close_session(self, session):
        
        try:
            session.close()
        except Exception as e:
            print(f"Error closing session: {e}")


    def execute_query(self, query):
        
        self.logger.debug(f"Executing query: {query}")
        session = self.get_session()
        try:
            result = session.execute(query).fetchall()
            self.logger.debug(f"Query executed successfully, found {len(result)} rows.")
            return result
        except SQLAlchemyError as e:
            self.logger.error(f"SQL query failed: {e}")
            session.rollback()
            raise
        except Exception as e:
            print(f"Error executing query: {e}")
            return []
        finally:
            self.close_session(session)


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\database_query_interface.py (Filename: database_query_interface.py) ###

from abc import ABC, abstractmethod

class DatabaseQueryInterface(ABC):
    

    @abstractmethod
    def get_average_temperature(self, city_id: int, year: int):
        
        pass

    @abstractmethod
    def get_precipitation_data(self, city_id: int, year: int):
        
        pass

    @abstractmethod
    def average_seven_day_precipitation(self, city_id: int, start_date: str):
        
        pass

    @abstractmethod
    def average_temp_by_city(self, city_id: int, start_date: str, end_date: str):
        
        pass

    @abstractmethod
    def average_annual_precipitation_by_country(self, country_id: int, year: int):
        
        pass

    @abstractmethod
    def does_city_exist(self, city_name: str):
        
        pass

    @abstractmethod
    def insert_city(self, city_data: dict):
        
        pass

    @abstractmethod
    def get_country_id_by_name(self, country_name: str):
        
        pass


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\geocoding_api_service.py (Filename: geocoding_api_service.py) ###

import logging
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from base_api_service import BaseApiService
from session_manager import SessionManager
from models import *

class GeocodingApiService(BaseApiService):
    

    def __init__(self, session_manager: SessionManager, max_retries=3, retry_delay=2):
        super().__init__(base_url="https://geocoding-api.open-meteo.com/v1/search", max_retries=max_retries, retry_delay=retry_delay)
        self.session = session_manager.get_session()


    def fetch_city_data(self, city_name):
        
        self.logger.debug(f"Fetching geocoding data for city: {city_name}")
        try:
            
            response = self._make_request(params={'name': city_name})
            
            data = response.get("results", [])

            if response and response.get("results"):
                self.logger.info(f"Found {len(response['results'])} results for {city_name}")
            else:
                self.logger.error(f"No results found for {city_name}")            
                raise ValueError(f"No results found for city: {city_name}")

            
            if len(data) > 1:
                print(f"Multiple locations found for '{city_name}':")
                for idx, city in enumerate(data):
                    
                    country_display = city.get('country', city.get('country_code', 'N/A'))
                    print(f"{idx + 1}. {city['name']}, {country_display} (Lat: {city['latitude']}, Lon: {city['longitude']})")

                
                try:
                    choice = int(input(f"Please select a city (1-{len(data)}): ")) - 1
                    if choice < 0 or choice >= len(data):
                        raise ValueError("Invalid choice")
                except ValueError as e:
                    self.logger.error(f"Invalid city choice: {e}")
                    print("Please enter a valid number.")
                    return self.fetch_city_data(city_name)
                
                city_info = data[choice]
            else:
                city_info = data[0]

            self.logger.debug(f"City selected: {city_info}")
            self.logger.debug(f"City keys: {city_info.keys()}")

            
            if 'name' not in city_info or 'latitude' not in city_info or 'longitude' not in city_info:
                self.logger.error(f"Incomplete city data: {city_info}")
                raise ValueError(f"Incomplete data for city: {city_info}")

            
            country_name = city_info.get('country', None) or city_info.get('country_code', None)  
            country = None
            if country_name:
                self.logger.debug(f"Extracted country: {country_name} from city info")
                self.logger.debug(f"Searching for country: {country_name}")
                
                
                country = self.session.query(Country).filter_by(name=country_name).first()
                
                if country:
                    self.logger.debug(f"Country {country_name} already exists in the database, skipping creation.")
                else:
                    
                    self.logger.debug(f"Country not found in database. Adding new country: {country_name}")
                    country = Country(name=country_name, timezone=city_info.get('timezone', 'Unavailable'))
                    self.session.add(country)
                    self.session.commit()
            else:
                
                self.logger.warning(f"No country found for city: {city_info['name']}. Storing as unavailable.")
                
                country = Country(name="Unavailable", timezone="Unavailable")
                self.session.add(country)
                self.session.commit()

            
            self.logger.debug(f"Creating city with name: {city_info['name']}, Latitude: {city_info['latitude']}, Longitude: {city_info['longitude']}")
            city = City(
                name=city_info['name'],
                latitude=city_info['latitude'],
                longitude=city_info['longitude'],
                timezone=city_info.get('timezone'),
                country_id=country.id if country else None  
            )
            self.session.add(city)
            self.session.commit()
            self.logger.debug(f"City {city.name} added to the database with ID {city.id}")
            return [city]

        except SQLAlchemyError as e:
            self.session.rollback()
            self.logger.error(f"Database error occurred while adding city: {e}")
            raise

        except ValueError as e:
            self.logger.error(f"Value error occurred: {e}")
            raise

        except Exception as e:
            self.session.rollback()
            self.logger.error(f"Unexpected error occurred: {e}")
            raise

### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\graph_output_handler.py (Filename: graph_output_handler.py) ###

import logging
import matplotlib.pyplot as plt
from constants import MONTH_NAMES

class GraphOutputHandler:
    

    logger = logging.getLogger(__name__)

    @staticmethod
    def handle_graph(choice, labels, values, title, xlabel=None, ylabel=None):
        
        GraphOutputHandler.logger.info(f"Title: {title}, X-Label: {xlabel}, Y-Label: {ylabel}")
        GraphOutputHandler.logger.info(f"Graph type: {choice}")
        GraphOutputHandler.logger.info(f"Labels: {labels}")
        GraphOutputHandler.logger.info(f"Values: {values}")

        
        values = [float(v) if isinstance(v, str) else v for v in values]

        
        valid_data = [(label, value) for label, value in zip(labels, values) if isinstance(value, (int, float))]
        if not valid_data:
            GraphOutputHandler.logger.warning("No valid numeric data available for graphing.")
            print("No valid numeric data to display as a graph.")
            return

        labels, values = zip(*valid_data)

        GraphOutputHandler.logger.debug(f"Filtered Labels: {labels}")
        GraphOutputHandler.logger.debug(f"Filtered Values: {values}")

        try:
            if choice == 2:
                GraphOutputHandler.plot_bar(labels, values, title, xlabel, ylabel)
            elif choice == 3:
                GraphOutputHandler.plot_pie(values, labels, title)
            else:
                print(f"Graph type '{choice}' is not supported.")
        except ValueError as e:
            GraphOutputHandler.logger.error(f"Graph rendering failed: {e}")
            print(f"Error: Unable to generate chart. {e}")
            print("Falling back to console output.")
            print("Results:", values)

    @staticmethod
    def plot_bar(labels: list[str], values: list[int], title: str, xlabel: str, ylabel: str):
        
        plt.close('all')

        GraphOutputHandler.logger.debug(f"plot bar, title: {title}")
        GraphOutputHandler.logger.debug(f"plot bar, xlabel: {xlabel}")
        GraphOutputHandler.logger.debug(f"plot bar, ylabel: {ylabel}")
        GraphOutputHandler.logger.debug(f"plot bar, Labels: {labels}")
        GraphOutputHandler.logger.debug(f"plot bar, Values: {values}")

        

        try:
            if not values or sum([v for v in values if isinstance(v, (int, float))]) == 0:
                GraphOutputHandler.logger.warning("No valid data for bar chart.")
                print("No valid data available for bar chart.")
                return

            plt.figure(figsize=(10, 6))
            plt.bar(labels, values)
            plt.title(title)
            plt.xlabel(xlabel)
            plt.ylabel(ylabel)
            plt.xticks(rotation=45, ha="right")
            plt.tight_layout()
            plt.show()
        except Exception as e:
            GraphOutputHandler.logger.error(f"Error plotting bar chart: {e}")
            print(f"Error generating chart: {e}. Falling back to console output.")
            GraphOutputHandler.logger.debug(f"Labels: {labels}, Values: {values}")


    @staticmethod
    def plot_pie(labels, values, title):
        
        plt.close('all')
        try:
            if not values or sum([v for v in values if isinstance(v, (int, float))]) == 0:
                GraphOutputHandler.logger.warning("No valid data for pie chart.")
                return

            values = [float(v) for v in values]
            plt.figure(figsize=(8, 8))
            plt.pie(values, labels=labels, autopct="%1.1f%%", startangle=140)
            plt.title(title)
            plt.tight_layout()
            plt.show()
        except Exception as e:
            GraphOutputHandler.logger.error(f"Pie chart error: {e}")
            print("Failed to generate pie chart. Falling back to console.")


    @staticmethod
    def plot_scatter(labels, values, title, xlabel, ylabel):
        
        plt.figure(figsize=(10, 6))
        plt.scatter(labels, values, c='blue', marker='o')
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.grid(True)
        plt.tight_layout()
        plt.show()

### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\initialise_db.py (Filename: initialise_db.py) ###

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base
import logging
import os

def initialise_db(db_path: str):
    
    
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[
            logging.StreamHandler()  
        ]
    )
    logger = logging.getLogger("initialize_db")

    try:
        abs_db_path = db_path
        
        db_directory = os.path.dirname(abs_db_path)
        if not os.path.exists(db_directory):
            raise FileNotFoundError(f"The directory for the database does not exist: {db_directory}")

        
        if os.path.exists(abs_db_path) and not os.access(abs_db_path, os.W_OK):
            raise PermissionError(f"Cannot write to the database file: {abs_db_path}")

        
        engine = create_engine(f"sqlite:///{abs_db_path}")
        print(f"engine: {engine}")

        
        logger.info("Creating tables...")
        Base.metadata.create_all(engine)
        logger.info("Tables created successfully.")

        
        Session = sessionmaker(bind=engine)
        session = Session()
        session.close()

        logger.info("Database initialization completed successfully.")
    except Exception as e:
        logger.error(f"An error occurred during database initialization: {e}")


if __name__ == "__main__":
    DB_PATH = "db\\CIS4044-N-SDI-OPENMETEO-PARTIAL.db"
    print("initialise_db db_path: {DB_PATH}")
    initialise_db(DB_PATH)


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\input_handler.py (Filename: input_handler.py) ###


from datetime import datetime
import logging


class InputHandler:
    

    logger = logging.getLogger(__name__)

    @staticmethod
    def get_integer_input(prompt: str) -> int:
        
        while True:
            try:
                choice = int(input(prompt))
                if choice < 0:
                    InputHandler.logger.warning(f"Invalid input: {choice}. It must be a positive integer.")
                    raise ValueError("Input must be a positive integer.")
                return choice
            except ValueError:
                InputHandler.logger.warning(f"User entered invalid input. Prompt: {prompt}")
                print("Invalid input. Please enter a valid number.")


    @staticmethod
    def get_year_input(prompt: str) -> str:
        
        while True:
            user_input = input(prompt)
            if len(user_input) == 4 and user_input.isdigit():
                return user_input
            print("Invlaid input. Enter a year as 4 digits i.e 2020")


    @staticmethod
    def get_date_input(prompt: str) -> str:
        
        while True:
            user_input = input(prompt)
            try:
                date = datetime.strptime(user_input, "%Y-%m-%d")
                
                if date > datetime.now():
                    print("The start date cannot be in the future. Please try again.")
                    continue
                return date.strftime("%Y-%m-%d")
            except ValueError:
                InputHandler.logger.warning("User entered an invalid date.")
                print("Invalid input. Please enter a date in the format yyyy-mm-dd (e.g., 2021-01-01).")


    @staticmethod
    def get_latitude_longitude(prompt: str) -> float:
        
        while True:
            try:
                value = float(input(prompt))
                if 'latitude' in prompt.lower() and -90 <= value <= 90:
                    return value
                elif 'longitude' in prompt.lower() and -180 <= value <= 180:
                    return value
                else:
                    print("Invalid range. Latitude must be -90 to 90, and Longitude must be -180 to 180.")
            except ValueError:
                print("Invalid input. Please enter a numeric value.")


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\location_manager.py (Filename: location_manager.py) ###

import logging
from datetime import datetime, timedelta
from sqlalchemy.orm import joinedload
from sqlalchemy.sql import func
from weather_data import WeatherData
from weather_api_service import WeatherApiService
from session_manager import SessionManager
from geocoding_api_service import GeocodingApiService
from models import *
from constants import *

class LocationManager:
    
    logger = logging.getLogger(__name__)

    def __init__(self, session_manager: SessionManager, geocoding_service: GeocodingApiService):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.session_manager = session_manager
        self.db_session = session_manager.get_session()
        self.geocoding_service = geocoding_service
        self.weather_service = WeatherApiService(self.db_session)


    def ensure_location_in_database(self, location_name):
        
        city_info = None
        self.session_manager.log_session_details()
        self.logger.debug(f"Starting transaction for '{location_name}'")

        
        self.logger.debug(f"Checking if city '{location_name}' exists in the database.")
        city = self.get_city_from_db(location_name)
        if city:
            self.logger.info(f"City '{location_name}' already exists in the database.")
            return [city]

        
        self.logger.debug(f"Fetching city data for '{location_name}' from Geocoding API.")
        location_data_list = self.geocoding_service.fetch_city_data(location_name)
        if len(location_data_list) > 1:
            
            self.logger.info(f"Multiple locations found for '{location_name}'. Please select one:")
            for idx, loc in enumerate(location_data_list):
                self.logger.debug(f"{idx + 1}. {loc.name}, {loc.country} (Lat: {loc.latitude}, Lon: {loc.longitude})")

            
            choice = 0  
            city_info = location_data_list[choice]
            self.logger.debug(f"City info selected: {city_info}")
        else:
            city_info = location_data_list[0]
            self.logger.debug(f"Single city found: {city_info}")

        
        self.logger.debug(f"Ensuring country '{city_info.country}' exists in the database.")
        country = self.ensure_country_exists(location_name)

        
        self.logger.debug(f"Ensuring city '{city_info.name}' exists in the database.")
        city = self.ensure_city_exists(city_info.name, city_info.latitude, city_info.longitude, country)

        
        self.session_manager.commit_session()
        self.logger.info(f"Location '{location_name}' added to the database.")

        self.logger.debug(f"This is the return value: {city}")
        return [city]


    def ensure_country_exists(self, country_name):
        
        country = self.db_session.query(Country).filter(Country.name.ilike(country_name)).first()
        if not country:
            self.logger.debug(f"Country '{country_name}' not found, creating new entry.")
            country = Country(name=country_name, timezone="Unavailable")
            self.db_session.add(country)
            self.session_manager.commit_session()
            self.logger.info(f"Country '{country_name}' added to the database.")
        else:
            self.logger.debug(f"Country '{country_name}' already exists in the database.")
        return country


    def ensure_city_exists(self, city_name, latitude, longitude, country):
        
        city = self.db_session.query(City).filter_by(name=city_name).first()

        if not city:
            self.logger.debug(f"City '{city_name}' not found, creating new entry.")
            city = City(name=city_name, latitude=latitude, longitude=longitude, timezone="Unavailable", country_id=country.id)
            self.db_session.add(city)
            self.session_manager.commit_session()
            self.logger.info(f"City '{city_name}' added to the database with ID {city.id}.")
        else:
            self.logger.debug(f"City '{city_name}' already exists in the database.")
        
        
        if not city.country:
            self.logger.debug(f"City '{city_name}' does not have a valid country association, linking to country '{country.name}'.")
            city.country = country
            self.db_session.commit()
        
        return city

    def get_city_from_db(self, location_name):
        
        self.logger.debug(f"Checking if location '{location_name}' exists in the database.")
        return self.db_session.query(City).options(joinedload(City.country)).filter_by(name=location_name).first()


    def fetch_location_weather_data(self, city_data, start_date, end_date):
        
        self.logger.debug(f"Checking if location '{city_data}' exists in the database.")

        
        city = self.get_city_from_data(city_data)

        if not city:
            self.logger.error(f"City '{city_data}' not found in the database.")
            return {}

        
        weather_data = self.fetch_weather_data_for_city(city, start_date, end_date)

        self.logger.error(f"Weather dated fetched '{weather_data[:5]}'")

        if not weather_data:
            self.logger.error(f"Failed to fetch valid weather data for city '{city.name}'.")
            return {}

        
        return self.process_weather_data(weather_data, city)


    def get_city_from_data(self, city_data):
        
        if isinstance(city_data, list) and city_data:
            city = city_data[0]
            self.logger.debug(f"Location data is a list, using the first city: {city.name}")
            return city
        elif isinstance(city_data, City):
            self.logger.debug(f"Location data is already a City object: {city_data.name}")
            return city_data
        else:
            self.logger.error(f"Invalid city data provided: {city_data}")
            return None


    def fetch_weather_data_for_city(self, city, start_date, end_date):
        
        self.logger.debug(f"Fetching weather data for city: {city.name} (Lat: {city.latitude}, Lon: {city.longitude})")
        
        weather_data = self.weather_service.fetch_weather_data(
            city.latitude, city.longitude, start_date, end_date, city.id
        )

        self.logger.debug(f"location_manager, weather data type {type(weather_data)}")

        return weather_data


    def fetch_weather_data_for_country(self, country, start_date, end_date):
        
        self.logger.debug(f"Fetching weather data for country: {country}, type: {type(country)}")
        
        weather_data = self.weather_service.fetch_weather_data_for_country(
            city.latitude, city.longitude, start_date, end_date, city.id
        )

        self.logger.debug(f"location_manager, weather data type {type(weather_data)}")

        return weather_data


    def process_weather_data(self, weather_data, city):
        
        self.logger.debug(f"Processing weather data for city {city}. len {len(weather_data)}")

        try:
            
            for data in weather_data:
                
                self.db_session.add(data)

            
            self.db_session.commit()
            self.logger.debug(f"Weather data successfully added to the database for city {city}.")
        except ValueError as e:
            self.logger.error(f"Error processing weather data for {city}: {str(e)}")
            return {}

        return weather_data


    def fetch_seven_day_precipitation(self, location_name, start_date):
        
        
        weather_data = []
        city = self.get_city_from_db(location_name)
        self.logger.debug(f"7 day dates, start {start_date}")

        start_date = datetime.strptime(start_date, "%Y-%m-%d")
        mid_date = start_date + timedelta(days=6)
        start_date = start_date.strftime("%Y-%m-%d")
        end_date = mid_date.strftime("%Y-%m-%d")

        
        if not city:
            self.logger.warning(f"City '{location_name}' not found in the database. Fetching data from Open-Meteo.")

            
            city_data_list = self.geocoding_service.fetch_city_data(city_name=location_name)
            self.logger.debug(f"7 day precip, city_data_list {city_data_list}")

            if city_data_list:
                self.logger.debug(f"7 day precip, {city_data_list[0]}")
                city_info = city_data_list[0]

                
                country = self.ensure_country_exists(location_name)
                city = self.ensure_city_exists(
                    city_info.name, city_info.latitude, city_info.longitude, country
                )

                self.logger.debug(f"Country information received: {country}, City data received: {city}")

                
                weather_data = self.fetch_weather_data_for_city(
                    city, start_date, end_date
                )
                self.logger.info(f"7 day precip, weather_data: {weather_data}")

                
                if weather_data:
                    self.process_weather_data(weather_data, location_name)
                    return weather_data
                else:
                    self.logger.error(f"No data available for {location_name} from Open-Meteo.")
                    print(f"No data available for {location_name}. Returning to the menu...")
                    return None  

        self.logger.debug(f"City '{location_name}' found in the database.")

        
        existing_data = self.db_session.query(DailyWeatherEntry.precipitation).filter(
            DailyWeatherEntry.city_id == city.id,
            DailyWeatherEntry.date.between(start_date, end_date)
        ).all()

        if existing_data:
            
            self.logger.info(f"Returning existing precipitation data for {location_name}.")
            return existing_data

        
        if weather_data:
            weather_data_obj = WeatherData(weather_data)

            if weather_data_obj.is_valid():
                daily_entries = weather_data_obj.map_to_daily_weather(city.id)
                self.db_session.add_all(daily_entries)
                self.db_session.commit_session()
                self.logger.info(f"Successfully fetched and saved data for {location_name}.")
                return daily_entries
            else:
                self.logger.error(f"Invalid weather data for {location_name}.")
                return None
        else:
            self.logger.error(f"Failed to fetch weather data for {location_name}.")
            return {}

    def average_annual_precipitation_by_country(self, country_name, year):
        
        
        country = self.db_session.query(Country).filter(Country.name.ilike(country_name)).first()

        if not country:
            self.logger.debug(f"Country '{country_name}' not found in the database.")
            return None

        
        start_date = datetime(year, 1, 1)
        end_date = datetime(year, 12, 31)

        self.logger.debug(f"Received country: {country.name}, start_date: {start_date}, end_date: {end_date})")

        
        monthly_precip = (
            self.db_session.query(
                func.extract('month', DailyWeatherEntry.date).label('month'),
                func.sum(DailyWeatherEntry.precipitation).label('monthly_precip')
            )
            .join(City, City.id == DailyWeatherEntry.city_id)
            .join(Country, Country.id == City.country_id)
            .filter(Country.id == country.id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .group_by('month')
            .order_by('month')
            .all()
        )

        self.logger.debug(f"by country, monthly_precip: {monthly_precip}")

        
        monthly_data = {month: round(precip, 2) for month, precip in monthly_precip}
        self.logger.debug(f"by country, monthly_data zipped: {monthly_data}")

        
        total_precip = (
            self.db_session.query(func.sum(DailyWeatherEntry.precipitation))
            .join(City, City.id == DailyWeatherEntry.city_id)
            .join(Country, Country.id == City.country_id)
            .filter(Country.id == country.id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .scalar()
        )

        self.logger.debug(f"by country, total_precip: {total_precip}")

        total_precip = round(total_precip, 2) if total_precip is not None else 0

        self.logger.debug(f"Total precipitation for {country_name} in {year}: {total_precip} mm")

        
        return {
            'total_precipitation': total_precip,
            'monthly_precipitation': monthly_data
        }


    def average_temp_by_city(self, start_date, end_date, location_name):
        self.logger.debug(f"loc man, average_temp_by_city")

        
        city = self.get_city_from_db(location_name)
        if not city:
            self.logger.error(f"City '{city}' not found in the database.")
            city_data = self.geocoding_service.fetch_city_data(location_name)

            if not city_data:
                self.logger.error(f"City '{location_name}' could not be fetched from Open-Meteo API.")
                return {}

            
            self.logger.debug(f"Adding city '{location_name}' to the database.")
            city = city_data[0]
            self.session_manager.commit_session()

        
        self.logger.error(f"City '{city}' found in the database.")
        weather_data = self.fetch_weather_data_for_city(city, start_date, end_date)

        self.logger.debug(f"Weather data: {weather_data}")

        
        if weather_data:
            average_temp = sum(entry.mean_temp for entry in weather_data) / len(weather_data)
            return average_temp
        else:
            self.logger.error(f"No weather data available for city '{city.name}' within the specified range.")
            return {}


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\main.py (Filename: main.py) ###






import logging
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from os.path import abspath
from initialise_db import initialise_db
from session_manager import SessionManager
from output_handler_registry import OutputHandlerRegistry
from console_output_handler import ConsoleOutputHandler
from graph_output_handler import GraphOutputHandler
from weather_api_service import WeatherApiService
from sqlite_query import SQLiteQuery
from menu_handler import MenuHandler
from database_manager import DatabaseManager



















OutputHandlerRegistry.register_handler("console", ConsoleOutputHandler.handle_console)
OutputHandlerRegistry.register_handler("bar_chart", GraphOutputHandler.handle_graph)
OutputHandlerRegistry.register_handler("pie_chart", GraphOutputHandler.handle_graph)




logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler()  
    ]
)
logger = logging.getLogger(__name__)
logging.getLogger('matplotlib').setLevel(logging.WARNING)

class WeatherDataApplication:
    

    def __init__(self, db_path: str):
        
        self.logger = logging.getLogger(self.__class__.__name__)

        
        print(f"main db_path: {db_path}")
        engine = create_engine(f"sqlite:///{db_path}")
        session_factory = sessionmaker(bind=engine)
        self.session_manager = SessionManager(session_factory)

        
        initialise_db(db_path)

        
        self.db_manager = DatabaseManager(engine)
        self.query_instance = SQLiteQuery(self.session_manager.get_session())
        self.menu_handler = MenuHandler(self.query_instance, self.db_manager, self.session_manager)
        self.weather_service = WeatherApiService(session=self.session_manager.get_session())

        self.logger.info("WeatherDataApplication initialised")

    def run(self):
        
        while True:
            choice = self.menu_handler.display_main_menu()

            try:
                if not self.menu_handler.handle_menu_choice(choice):
                    print("Exiting the application...")
                    break
            except Exception as e:
                self.logger.error(f"An error occurred: {e}")
                print("An unexpected error occurred. Please try again.")

        
        self.session_manager.close_session()

if __name__ == "__main__":
    
    DB_PATH = "db\\CIS4044-N-SDI-OPENMETEO-PARTIAL.db"
    app = WeatherDataApplication(DB_PATH)
    app.run()


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\menu_handler.py (Filename: menu_handler.py) ###


import logging
from input_handler import InputHandler
from location_manager import LocationManager
from output_handler import OutputHandler
from console_output_handler import ConsoleOutputHandler
from session_manager import SessionManager
from geocoding_api_service import GeocodingApiService
from constants import *

class MenuHandler:
    

    def __init__(self, query_instance, db_manager, session_manager: SessionManager):
        
        self.logger = logging.getLogger(self.__class__.__name__)
        self.query_instance = query_instance
        self.db_manager = db_manager
        self.session_manager = session_manager
        self.geocoding_service = GeocodingApiService(self.session_manager)
        self.location_manager = LocationManager(self.session_manager, self.geocoding_service)


    def display_main_menu(self):
        
        print("\nWeather Data Application")
        print("1. View all countries")
        print("2. View all cities")
        print("3. Get average annual temperature")
        print("4. Get seven-day precipitation")
        print("5. Get mean temperature by city")
        print("6. Get annual precipitation by country")
        print("0. Exit")
        return InputHandler.get_integer_input("Enter your choice: ")


    def handle_menu_choice(self, choice):
        
        if choice == MENU_VIEW_COUNTRIES:
            self.view_countries()
        elif choice == MENU_VIEW_CITIES:
            self.view_cities()
        elif choice == MENU_AVG_TEMP:
            self.average_annual_temperature()
        elif choice == MENU_7DAY_PRECIP:
            self.average_seven_day_precipitation()
        elif choice == MENU_MEAN_TEMP_CITY:
            self.average_temp_by_city()
        elif choice == MENU_ANNUAL_PRECIP_CITY:
            self.average_annual_precipitation_by_country()
        elif choice == MENU_EXIT:
            return False
        else:
            print("Invalid choice, try again")
        return True


    def view_countries(self):
        
        results = self.query_instance.get_all_countries()
        OutputHandler.handle_output(1, results, TITLE_COUNTRIES, X_LABEL_COUNTRIES, Y_LABEL_COUNTRY_ID)


    def view_cities(self):
        
        results = self.query_instance.get_all_cities()
        OutputHandler.handle_output(1, results, TITLE_CITIES, X_LABEL_COUNTRIES, Y_LABEL_COUNTRY_ID)


    def average_annual_temperature(self):
        
        location_name = input("Enter location name: ")
        if not location_name:
            print("Location name cannot be empty. Please enter a valid city name.")
            return
        year = InputHandler.get_year_input("Enter year as YYYY: ")

        start_date = f"{year}{START_OF_YEAR}"
        end_date = f"{year}{END_OF_YEAR}"
        self.session_manager.log_session_details()

        city_data = self.location_manager.ensure_location_in_database(location_name)
        self.session_manager.log_session_details()

        weather_data = self.location_manager.fetch_location_weather_data(city_data, start_date, end_date)
        self.logger.debug(f"menu_handler, weather data: {weather_data[:5]}")

        monthly_data = self.query_instance.get_monthly_average_temperature(weather_data)
        self.logger.debug(f"menu_handler, monthly data: {monthly_data} type: {type(monthly_data)}")

        self.delegate_output(monthly_data, title=TITLE_AVG_TEMP, xlabel=X_LABEL_YEAR, ylabel=Y_LABEL_TEMPERATURE)


    def average_seven_day_precipitation(self):
        
        location_name = input("Enter location name: ")
        if not location_name:
            print("Location name cannot be empty. Please enter a valid city name.")
            return

        start_date = InputHandler.get_date_input("Enter start date (yyyy-mm-dd): ")
        self.logger.debug(f"avg 7 day precip start_date: {start_date}")

        results = self.location_manager.fetch_seven_day_precipitation(location_name, start_date)
        self.logger.debug(f"avg 7 day precip type: {type(results)}, {results}")

        
        self.delegate_output(results, title=TITLE_7DAY_PRECIP, xlabel=X_LABEL_CITIES, ylabel=Y_LABEL_PRECIPITATION)


    def average_temp_by_city(self):
        
        location_name = input("Enter location name: ")
        
        if not location_name:
            print("Location name cannot be empty. Please enter a valid city name.")
            return

        date_from = InputHandler.get_date_input("Enter start date (format: yyyy-mm-dd): ")
        date_to = InputHandler.get_date_input("Enter end date (format: yyyy-mm-dd): ")

        results = self.location_manager.average_temp_by_city(date_from, date_to, location_name)
        self.delegate_output(results, title=TITLE_MEAN_TEMP_CITY, xlabel=X_LABEL_TEMPERATURE, ylabel=Y_LABEL_TEMPERATURE)


    def average_annual_precipitation_by_country(self):
        
        year = InputHandler.get_year_input("Enter year as YYYY: ")
        location_name = input("Enter location name: ")

        if not location_name:
            print("Location name cannot be empty. Please enter a valid city name.")
            return

        
        country = self.location_manager.ensure_location_in_database(location_name)

        if not country:
            print(f"City '{country}' not found in the database.")
            return
        else:
            self.logger.debug(f"Found city: {type(country)}, year: {type(year)}, {country}")


        
        year = int(year)
        results = self.location_manager.average_annual_precipitation_by_country(location_name, year)
        self.logger.debug(f"results of type: {type(results)}, {results}")

        if results:
            self.delegate_output(results, title=TITLE_ANNUAL_PRECIP, xlabel=X_LABEL_PRECIPITATION, ylabel=Y_LABEL_PRECIPITATION)
        else:
            print("No precipitation data available for this country and year.")


    def delegate_output(self, results, title, xlabel, ylabel):
        
        self.logger.debug(f"delegating output")
        print("How would you like to display the data?")
        print("1. Console")
        print("2. Bar Chart")
        print("3. Pie Chart")
        choice = InputHandler.get_integer_input("Enter your choice: ")

        self.logger.debug(f"User selected display option: {choice}")
        self.logger.debug(f"Graph details: {title, xlabel, ylabel}")
        self.logger.debug(f"Results being passed: {results}")

        OutputHandler.handle_output(choice, results, title, xlabel, ylabel)


    def exit_application(self):
            
            print("Closing application")
            self.db_manager.close_connection()


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\output_handler.py (Filename: output_handler.py) ###

import logging
from datetime import datetime, date, timedelta
from models.city import City
from models.country import Country
from models.daily_weather_entry import DailyWeatherEntry
from output_handler_registry import OutputHandlerRegistry
from sqlalchemy.engine.row import Row
from constants import *

class OutputHandler:
    
    logger = logging.getLogger(__name__)

    @staticmethod
    def handle_output(choice, results, title=None, xlabel=None, ylabel=None):
        
        if not results:
            print("No data available.")
            OutputHandler.logger.warning("No data available.")
            return
        results = OutputHandler._standardise_results(results, title)
        
        
        if not isinstance(results, list):
            print("Results should be a list or a numeric value. Falling back to console.")
            OutputHandler._display_table(results)
            return
        labels, values = OutputHandler._extract_labels_values_for_cities_and_countries(results)
        handlers = {
            1: "console",
            2: "bar_chart",
            3: "pie_chart"
        }
        handler_name = handlers.get(choice)
        handler = OutputHandlerRegistry.get_handler(handler_name)
        
        try:
            if handler_name == "console":
                OutputHandler._display_table(results)
            elif handler:
                OutputHandler.logger.debug(f"Graphing with labels: {labels} and values: {values}")
                handler(choice, labels, values, title, xlabel, ylabel)
            else:
                raise ValueError(f"Unsupported output type: {handler_name}")
        except Exception as e:
            OutputHandler.logger.error(f"Error during output handling. Handler: {handler_name}, Choice: {choice}, Error: {e}")
            print(f"Error: Unable to generate chart. {e}")
            print("Falling back to console output.")
            OutputHandler._display_table(results)

    @staticmethod
    def _display_table(results):
        
        if not results or not isinstance(results, list):
            print()
            print("No data to display.")
            return
        if 'Temperature' in results[0]:
            OutputHandler._display_temperature_table(results)
        elif 'precipitation' in results[0]:
            OutputHandler._display_precipitation_table(results)
        else:
            OutputHandler._print_to_console(results)

    @staticmethod
    def _print_to_console(results):
        
        headers = list(results[0].keys())
        
        column_widths = {header: len(header) for header in headers}
        
        for row in results:
            
            for header in headers:
                
                value = row.get(header, "")
                
                
                if header in {"id", "country_id"} and value is not None:
                    try:
                        value = int(float(value))
                        
                    except ValueError:
                        value = value
                
                if isinstance(value, (int, float)) and header not in {"latitude", "longitude"}:
                    value = round(value, 2)
                    value = f"{value:.2f}"
                column_widths[header] = max(column_widths[header], len(str(value)))
        
        header_format = " | ".join(f"{{:<{column_widths[header]}}}" for header in headers)
        separator = "-+-".join("-" * column_widths[header] for header in headers)
        
        print()
        print(header_format.format(*headers))
        print(separator)
        
        for row in results:
            row_values = [
                str(int(row.get(header, 0))) if header in {"id", "country_id"} and row.get(header) is not None
                else str(row.get(header, "N/A"))
                for header in headers
            ]
            print(header_format.format(*row_values))

    @staticmethod
    def _display_temperature_table(results):
        
        if not results:
            OutputHandler.logger.info("No temperature data available.")
            return
        headers = ['Month', 'Temperature °C']
        column_widths = {header: len(header) for header in headers}
        column_widths['Month'] = max(len(month) for month in MONTH_NAMES)
        for item in results:
            temperature = item.get("Temperature")
            if temperature is not None:
                column_widths['Temperature °C'] = max(column_widths['Temperature °C'], len(f"{float(temperature):.2f}"))
        
        for item in results:
            for header in headers:
                value = item.get(header.lower(), '')
                column_widths[header] = max(column_widths[header], len(str(value)))
        
        header_line = " | ".join(f"{header:<{column_widths[header]}}" for header in headers)
        separator = "-+-".join("-" * column_widths[header] for header in headers)
        print()
        print(header_line)
        print(separator)
        
        for item in results:
            month = item.get("Month")
            temperature = item.get("Temperature")
            if month is not None and temperature is not None:
                try:
                    temperature = float(temperature)
                    month_name = MONTH_NAMES[month - 1]
                    
                    print(f"{month_name:<{column_widths['Month']}} | {temperature:<{column_widths['Temperature °C']}.2f}")
                except ValueError:
                    OutputHandler.logger.error(f"Invalid temperature value: {temperature}")
                    print(f"{month_name:<{column_widths['Month']}} | Invalid Temperature")
            else:
                OutputHandler.logger.error(f"Missing Month or Temperature in item: {item}")
                print(f"{'Invalid Data':<{column_widths['Month']}} | {'Invalid Data':<{column_widths['Temperature °C']}}")

    @staticmethod
    def _display_precipitation_table(results):
        
        if not results:
            OutputHandler.logger.info(f"No precipitation data available.")
            return
        headers = ['ID', 'Date', 'Precipitation']
        column_widths = {header: len(header) for header in headers}
        for row in results:
            for header in headers:
                value = row.get(header.lower(), '')
                column_widths[header] = max(column_widths[header], len(str(value)))
        
        header_line = " | ".join(f"{header:<{column_widths[header]}}" for header in headers)
        separator = "-+-".join("-" * column_widths[header] for header in headers)
        print()
        print(header_line)
        print(separator)
        
        for row in results:
            print(" | ".join(f"{str(row.get(header.lower(), '')):<{column_widths[header]}}" for header in headers))

    @staticmethod
    def _standardise_results(results, title):
        
        OutputHandler.logger.debug(f"Standardising results of type: {title}")

        
        if isinstance(results, (int, float)):
            return [{"Result": f"{results:.2f}"}]

        
        if isinstance(results, dict):
            if 'Average Seven-Day Precipitation' == title:
                total_precip = results.get('total_precipitation', 0)
                
                results['total_precipitation'] = round(total_precip, 2)

            if 'Average Temperature' == title:
                
                standardized_results = [{"Month": month, "Temperature": f"{temp:.2f}"} for month, temp in results.items()]
                
                return standardized_results

            if 'Mean Temperature by City' == title:
                total_precip = results.get('total_precipitation', 0)
                
                results['total_precipitation'] = round(total_precip, 2)
            return results

        
        if isinstance(results, list):
            standardised = []
            for row in results:
                if isinstance(row, tuple):
                    OutputHandler.logger.debug(f"Row is a tuple, value: {row[0]}")
                    standardised.append({
                        'precipitation': round(row[0], 2)
                    })
                elif isinstance(row, DailyWeatherEntry):
                    standardised.append({
                        'date': row.date,
                        'precipitation': float(row.precipitation),
                        'max_temp': float(row.max_temp),
                        'min_temp': float(row.min_temp),
                    })
                elif isinstance(row, (City, Country)):
                    if hasattr(row, 'to_dict'):
                        standardised.append(row.to_dict())
                    else:
                        OutputHandler.logger.debug("No to_dict method found.")
                elif isinstance(row, dict):
                    OutputHandler.logger.debug("Row is already a dictionary")
                    standardised.append(row)
            
            return standardised

        
        OutputHandler.logger.debug("No results to standardise")
        return []

    @staticmethod
    def _display_single_result(result):
        
        print(f"Result: {result:.2f}")

    @staticmethod
    def _extract_labels_values_for_cities_and_countries(results):
        

        
        if not results or not isinstance(results[0], dict):
            return ["No data"], [0]
        
        if isinstance(results[0], dict) and 'date' in results[0] and 'precipitation' in results[0]:
            labels = [str(row['date']) for row in results]
            values = [row['precipitation'] for row in results]
            return labels, values

        
        labels = list(results[0].keys())
        if isinstance(results[0], dict) and "Month" in results[0]:
            
            values = [row["Temperature"] for row in results]
            labels = OutputHandler._generate_time_period_labels(results)
        else:
            values = [list(row.values()) for row in results]
            labels = [list(row.keys()) for row in results]
        
        return labels, values

    @staticmethod
    def handle_console(results):
        
        
        if isinstance(results, (int, float)):
            print(f"Experiencing {results:.2f} mm of precipitation")
            return
        
        if not results or not isinstance(results, list) or not isinstance(results[0], dict):
            print("No valid data available.")
            return
        
        headers = results[0].keys()
        header_line = " | ".join(headers)
        print(f"Header Line: {header_line}")
        print("-" * len(header_line))
        
        for result in results:
            row_line = " | ".join(str(result.get(key, "N/A")) for key in headers)
            print(row_line)

    @staticmethod
    def sqlite_row_to_dict(rows):
        
        return [dict(row) for row in rows]

    @staticmethod
    def _generate_time_period_labels(results):
        
        import logging
        logger = logging.getLogger(__name__)

        
        logger.debug(f"Received results of type: {type(results)}")
        logger.debug(f"First 5 entries: {results[:5]}")

        
        start_date = datetime.strptime(results[0]['date'], '%Y-%m-%d')
        end_date = datetime.strptime(results[-1]['date'], '%Y-%m-%d')

        logger.debug(f"Start date: {start_date}, End date: {end_date}")

        
        days_difference = (end_date - start_date).days + 1
        logger.debug(f"Days difference: {days_difference}")

        labels = []

        if days_difference <= 14:
            
            logger.debug("Generating daily labels.")
            for i in range(days_difference):
                label_date = start_date + timedelta(days=i)
                labels.append(label_date.strftime('%Y-%m-%d'))

        elif days_difference <= 31:
            
            logger.debug("Generating labels every 2 days.")
            for i in range(0, days_difference, 2):
                label_date = start_date + timedelta(days=i)
                labels.append(label_date.strftime('%Y-%m-%d'))

        else:
            
            months_difference = (end_date.year - start_date.year) * 12 + end_date.month - start_date.month + 1
            logger.debug(f"Months difference: {months_difference}")

            if months_difference <= 12:
                
                logger.debug("Generating monthly labels.")
                for i in range(months_difference):
                    month_label = (start_date + timedelta(days=30 * i)).strftime('%b %Y')
                    labels.append(month_label)

            elif months_difference <= 24:
                
                logger.debug("Generating quarterly labels.")
                for i in range(0, months_difference, 3):
                    quarter_label = f"Q{(i // 3) + 1} ({start_date.year + (i // 12)})"
                    labels.append(quarter_label)

            elif months_difference <= 48:
                
                logger.debug("Generating half-yearly labels.")
                for i in range(0, months_difference, 6):
                    half_year_label = f"H{(i // 6) + 1} ({start_date.year + (i // 12)})"
                    labels.append(half_year_label)

            else:
                
                logger.debug("Generating yearly labels.")
                for i in range(0, months_difference, 12):
                    year_label = f"{start_date.year + (i // 12)}"
                    labels.append(year_label)

        logger.debug(f"Generated labels: {labels}")
        logger.debug(f"Label count: {len(labels)}")
        return labels


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\output_handler_registry.py (Filename: output_handler_registry.py) ###

class OutputHandlerRegistry:
    _handlers = {}

    @classmethod
    def register_handler(cls, name, handler):
        
        cls._handlers[name] = handler

    @classmethod
    def get_handler(cls, name):
        
        return cls._handlers.get(name)


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\results_validator.py (Filename: results_validator.py) ###



import sqlite3

class ResultsValidator:
    

    @staticmethod
    def validate(results):
        
        if results is None:
            print("No data found.")
            return False

        if isinstance(results, (int, float)):
            return True

        if isinstance(results, list):
            if all(isinstance(row, sqlite3.Row) for row in results) or all(isinstance(row, dict) for row in results):
                return len(results) > 0

        print("Invalid data format.")
        return False


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\session_manager.py (Filename: session_manager.py) ###

import logging
from sqlalchemy.orm import sessionmaker, scoped_session
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError

class SessionManager:
    
    logger = logging.getLogger(__name__)

    _instance = None

    def __new__(cls, db_session_factory):
        
        if cls._instance is None:
            cls._instance = super(SessionManager, cls).__new__(cls)
            cls._instance.db_session_factory = db_session_factory
            cls._instance.logger = logging.getLogger(__name__)
        return cls._instance


    def get_session(self):
        
        if not hasattr(self, 'session'):
            self.session = self.db_session_factory()
            self.logger.debug("New session created.")
        return self.session


    def commit_session(self):
        
        try:
            self.logger.debug(f"Committing session: {id(self.session)}")
            self.session.commit()
            self.logger.debug(f"Session committed successfully: {id(self.session)}")
        except SQLAlchemyError as e:
            self.session.rollback()
            self.logger.error(f"Error during commit on session {id(self.session)}: {e}")


    def close_session(self):
        
        if hasattr(self, 'session'):
            self.logger.debug(f"Closing session: {id(self.session)}")
            self.session.close()
            self.logger.debug(f"Session closed: {id(self.session)}")
            del self.session
        else:
            self.logger.warning("No session to close.")

    def log_session_details(self):
        
        if hasattr(self, 'session'):
            self.logger.debug(f"Session details: {id(self.session)}, Active: {self.session.is_active}, Transaction: {self.session.in_transaction()}")
        else:
            self.logger.warning("No active session to log.")

### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\sqlite_query.py (Filename: sqlite_query.py) ###

import logging
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func
from sqlalchemy import exists
from models.daily_weather_entry import DailyWeatherEntry
from models.city import City
from models.country import Country
from database_query_interface import DatabaseQueryInterface
from collections import defaultdict



class SQLiteQuery(DatabaseQueryInterface):
    

    def __init__(self, session: Session):
        
        self.logger = logging.getLogger(self.__class__.__name__)
        self.session = session


    def get_all_countries(self):
        
        return self.session.query(Country).all()


    def get_country_by_name(self, country_name):
        
        return self.session.query(Country).filter(Country.name == country_name).first()


    def get_country_by_id(self, country_name):
        
        return self.session.query(Country).filter(Country.name == country_name).first()


    def get_all_cities(self):
        
        return self.session.query(City).all()


    def get_average_temperature(self, city_id: int, year: int):
        
        
        self.logger.debug(f"Received city_id: {city_id} (type: {type(city_id)}), year: {year} (type: {type(year)})")

        
        int_year = int(year)
        start_date = datetime(int_year, 1, 1)
        end_date = datetime(int_year, 12, 31)

        
        self.logger.debug(f"Generated start_date: {start_date} (type: {type(start_date)}), end_date: {end_date} (type: {type(end_date)})")

        
        avg_temp = (
            self.session.query(func.avg(DailyWeatherEntry.mean_temp))
            .filter(DailyWeatherEntry.city_id == city_id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .scalar()
        )

        
        

        
        if avg_temp is None:
            self.logger.warning(f"No average temperature found for city {city_id} in year {year}.")
        else:
            self.logger.debug(f"Average temperature: {avg_temp} found for city {city_id} in year {year}.")
        return avg_temp


    def get_precipitation_data(self, city_id: int, year: int):
        
        start_date = datetime(year, 1, 1)
        end_date = datetime(year, 12, 31)

        total_precip = (
            self.session.query(func.sum(DailyWeatherEntry.precipitation))
            .filter(DailyWeatherEntry.city_id == city_id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .scalar()
        )
        return total_precip


    def average_seven_day_precipitation(self, city_name, start_date):
        
        start_date = datetime.strptime(start_date, "%Y-%m-%d")
        end_date = start_date + timedelta(days=6)

        city = self.session.query(City).filter(City.name.ilike(city_name)).first()

        avg_precip = (
            self.session.query(DailyWeatherEntry.date, DailyWeatherEntry.precipitation)
            .filter(DailyWeatherEntry.city_id == city.id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .all()
        )
        precip_data = [(entry[0], entry[1]) for entry in avg_precip]
        self.logger.debug(f"7 day precip: {precip_data}")
        return precip_data


    def average_temp_by_city(self, start_date, end_date, city_name):
        
        self.logger.debug(f"Received city: {city_name}, start_date: {start_date}, end_date: {end_date})")

        start_date = datetime.strptime(start_date, "%Y-%m-%d")
        end_date = datetime.strptime(end_date, "%Y-%m-%d")

        city = self.session.query(City).filter(City.name.ilike(city_name)).first()

        if not city:
            self.logger.error(f"City '{city_name}' not found in the database.")
            return None

        self.logger.debug(f"Fetched city: {city.name} with ID: {city.id}")

        
        avg_temp = (
            self.session.query(func.avg(DailyWeatherEntry.mean_temp))
            .filter(DailyWeatherEntry.city_id == city.id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .scalar()
        )

        self.logger.debug(f"Average temperature for {city_name} from {start_date} to {end_date}: {avg_temp} °C")

        return avg_temp



    def average_annual_precipitation_by_country(self, country_name, year):
        
        
        country = self.session.query(Country).filter(Country.name.ilike(country_name)).first()

        if not country:
            self.logger.error(f"Country '{country_name}' not found in the database.")
            return None

        
        start_date = datetime(year, 1, 1)
        end_date = datetime(year, 12, 31)

        self.logger.debug(f"Received country: {country.name}, start_date: {start_date}, end_date: {end_date})")

        
        monthly_precip = (
            self.session.query(
                func.extract('month', DailyWeatherEntry.date).label('month'),
                func.sum(DailyWeatherEntry.precipitation).label('monthly_precip')
            )
            .join(City, City.id == DailyWeatherEntry.city_id)
            .join(Country, Country.id == City.country_id)
            .filter(Country.id == country.id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .group_by('month')
            .order_by('month')
            .all()
        )

        
        monthly_data = {month: round(precip, 2) for month, precip in monthly_precip}

        
        total_precip = (
            self.session.query(func.sum(DailyWeatherEntry.precipitation))
            .join(City, City.id == DailyWeatherEntry.city_id)
            .join(Country, Country.id == City.country_id)
            .filter(Country.id == country.id)
            .filter(DailyWeatherEntry.date.between(start_date, end_date))
            .scalar()
        )

        total_precip = round(total_precip, 2) if total_precip is not None else 0

        self.logger.debug(f"Total precipitation for {country_name} in {year}: {total_precip} mm")

        
        return {
            'total_precipitation': total_precip,
            'monthly_precipitation': monthly_data
        }


    def does_city_exist(self, city_name: str):
        
        exists_query = self.session.query(exists().where(City.name == city_name))
        return self.session.query(exists_query).scalar()


    def get_country_id_by_name(self, country_name: str):
        
        country = self.session.query(Country).filter(Country.name == country_name).first()
        return country.id if country else None


    def insert_city(self, city_data: dict):
        
        country_id = self.get_country_id_by_name(city_data['country'])
        if country_id is None:
            raise ValueError(f"Country '{city_data['country']}' not found in the database.")

        new_city = City(
            name=city_data['name'],
            latitude=city_data['latitude'],
            longitude=city_data['longitude'],
            country_id=country_id,
            timezone=city_data['timezone']
        )

        self.session.add(new_city)
        self.session.commit()
        self.session.refresh(new_city)
        return new_city


    def get_monthly_average_temperature(self, daily_weather_entries):
        
        monthly_data = defaultdict(list)

        for entry in daily_weather_entries:
            month = entry.date.month
            monthly_data[month].append(entry.mean_temp)

        
        monthly_avg_temp = {month: sum(temps)/len(temps) for month, temps in monthly_data.items()}

        return monthly_avg_temp

### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\weather_api_service.py (Filename: weather_api_service.py) ###

from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from constants import *
from models import DailyWeatherEntry
from base_api_service import BaseApiService
from weather_data import WeatherData

class WeatherApiService(BaseApiService):
    
    def __init__(self, session: Session, max_retries=3, retry_delay=2):
        base_url = "https://archive-api.open-meteo.com/v1/archive"
        super().__init__(base_url=base_url, max_retries=max_retries, retry_delay=retry_delay)
        self.session = session


    def fetch_weather_data(self, latitude, longitude, start_date, end_date, city_id):
        
        self.logger.debug(f"Initial values: {latitude}, {longitude}, {start_date}, {end_date}, {city_id}")
        params = {
            LATITUDE: latitude,
            LONGITUDE: longitude,
            START_DATE: start_date,
            END_DATE: end_date,
            TIMEZONE: "auto",
            DAILY: ','.join([TEMPERATURE_2M_MAX, TEMPERATURE_2M_MIN, PRECIPITATION_SUM]),
        }
        self.logger.debug(f"Request params: {params}")

        try:
            data = self._make_request(params=params)
            

            if "error" in data:
                self.logger.error(f"Weather API returned an error: {data['error']}")
                raise ValueError(f"weather_api, Weather API error: {data['error']}")

            if "daily" in data:
                
                
                weather_data = WeatherData(data["daily"])
                self.logger.debug(f"weather_api, Weather data mapped: {weather_data}")

                if weather_data.is_valid():
                    
                    self.logger.debug(f"Valid weather data received: {weather_data}")
                    self.logger.debug(f"weather_api_service, City Id: {city_id}.")

                    daily_weather_entries = weather_data.map_to_daily_weather(city_id)
                    self.logger.debug(f"Daily weather data: {daily_weather_entries[:5]}")
                    
                    self._store_weather_data(daily_weather_entries, city_id)
                    return daily_weather_entries
                else:
                    self.logger.error("Invalid weather data received.")
                    raise ValueError("Weather data is invalid or incomplete.")
            else:
                raise ValueError("Weather API returned unexpected structure.")
        except Exception as e:
            self.logger.error(f"Weather API Error: {e}")
            return WeatherData({
                TEMPERATURE_2M_MAX: [],
                TEMPERATURE_2M_MIN: [],
                PRECIPITATION_SUM: []
            })


    def _store_weather_data(self, daily_weather_entries, city_id: int):
        
        self.logger.debug("weather_api_service, _store_weather_data")
        try:
            
            for entry in daily_weather_entries:
                self.session.add(entry)

            self.session.commit()
            self.logger.debug(f"Stored weather data for city ID {city_id}")
        except SQLAlchemyError as e:
            self.session.rollback()
            self.logger.error(f"Failed to store weather data: {e}")
            raise


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\weather_data.py (Filename: weather_data.py) ###

import logging
from datetime import datetime
from models.daily_weather_entry import DailyWeatherEntry

class WeatherData:
    def __init__(self, weather_data: dict):
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)

        
        if not isinstance(weather_data, dict):
            self.logger.error(f"Invalid data format: {type(weather_data)}. Expected a dictionary.")
            raise ValueError("weather_data must be a dictionary.")

        self.temperature_2m_max = weather_data.get("temperature_2m_max", [])
        self.temperature_2m_min = weather_data.get("temperature_2m_min", [])
        self.precipitation_sum = weather_data.get("precipitation_sum", [])
        self.dates = weather_data.get("time", [])

        self.logger.debug(f"Weather data initialized with {len(self.dates)} entries.")


    def is_valid(self):
        
        if not self.temperature_2m_max or not self.temperature_2m_min or not self.precipitation_sum or not self.dates:
            self.logger.error(f"Invalid weather data. Missing or empty required fields: {self.temperature_2m_max}, {self.temperature_2m_min}, {self.precipitation_sum}, {self.dates}")
            return False
        return True


    def is_valid_list(self, weather_data_list):
        
        self.logger.debug(f"weather_day, is_valid_list called for {len(weather_data_list)} items")

        for index, weather_data in enumerate(weather_data_list):
            if not weather_data.is_valid():
                self.logger.error(f"Weather data at index {index} is invalid.")
                return False
        return True


    def map_to_daily_weather(self, city_id: int):
        
        if not self.is_valid():
            self.logger.error("Invalid weather data. Missing or empty required fields.")
            raise ValueError("Invalid weather data. Missing or empty required fields.")

        self.logger.debug("Mapping raw weather data to DailyWeatherEntry objects...")
        self.logger.debug(f"City ID: {city_id}")

        daily_weather_entries = []

        for date, temp_max, temp_min, precip in zip(
                self.dates,
                self.temperature_2m_max,
                self.temperature_2m_min,
                self.precipitation_sum
        ):

            mean_temp = (temp_max + temp_min) / 2 if temp_max is not None and temp_min is not None else 0

            daily_weather_entries.append(
                DailyWeatherEntry(
                    city_id=city_id,
                    date=datetime.strptime(date, "%Y-%m-%d").date(),
                    min_temp=temp_min if temp_min is not None else 0,
                    max_temp=temp_max if temp_max is not None else 0,
                    mean_temp=mean_temp,
                    precipitation=precip if precip is not None else 0
                )
            )

        self.logger.debug(f"Mapped {len(daily_weather_entries)} entries to DailyWeatherEntry objects.")
        return daily_weather_entries


    def __str__(self):
        
        return (f"Weather Data:\n"
                f"Dates: {len(self.dates)} entries\n"
                f"Max Temperatures: {self.temperature_2m_max[:5]}... (first 5)\n"
                f"Min Temperatures: {self.temperature_2m_min[:5]}... (first 5)\n"
                f"Precipitation: {self.precipitation_sum[:5]}... (first 5)")


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\__init__.py (Filename: __init__.py) ###

from .constants import DAILY_WEATHER_TBL, COUNTRIES_TBL, CITIES_TBL
from .database_manager import DatabaseManager
from .sqlite_query import SQLiteQuery
from .main import WeatherDataApplication
from .input_handler import InputHandler
from .output_handler import OutputHandler


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\models\city.py (Filename: city.py) ###

from sqlalchemy import Column, Integer, String, Float, ForeignKey
from sqlalchemy.orm import relationship
from . import Base

class City(Base):
    __tablename__ = 'cities'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    latitude = Column(Float, nullable=False)
    longitude = Column(Float, nullable=False)
    timezone = Column(String, nullable=False)
    country_id = Column(Integer, ForeignKey('countries.id'), nullable=False)

    
    country = relationship("Country", back_populates="cities")
    weather_entries = relationship('DailyWeatherEntry', back_populates='city', cascade="all, delete-orphan")


    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "latitude": self.latitude,
            "longitude": self.longitude,
            "timezone": self.timezone,
            "country_id": self.country_id,
            "country_name": self.country.name if self.country else None,
        }


    def __str__(self):
        name = self.name if self.name is not None else 'Unknown'
        latitude = self.latitude if self.latitude is not None else 'Unknown'
        longitude = self.longitude if self.longitude is not None else 'Unknown'
        country_id = self.country_id if self.country_id is not None else 'Unknown'

        
        if self.country:
            country_name = self.country.name if self.country.name else 'Unknown'
        else:
            country_name = 'Unknown'

        return (f"City(id={self.id}, name='{name}', latitude={latitude}, "
                f"longitude={longitude}, country_id={country_id}, country_name='{country_name}')")

### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\models\country.py (Filename: country.py) ###

from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship
from . import Base

class Country(Base):
    __tablename__ = 'countries'

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    timezone = Column(String, nullable=False)

    cities = relationship("City", back_populates="country")

    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "timezone": self.timezone,
        }

    def __str__(self):
        name = self.name if self.name is not None else 'Unknown'
        timezone = self.timezone if self.timezone is not None else 'Unknown'
        return f"<Country(id={self.id}, name='{name}', timezone='{timezone}')>"


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\models\daily_weather_entry.py (Filename: daily_weather_entry.py) ###

from sqlalchemy import Column, Integer, Float, Date, ForeignKey
from sqlalchemy.orm import relationship
from . import Base

class DailyWeatherEntry(Base):
    __tablename__ = 'daily_weather_entries'

    id = Column(Integer, primary_key=True, index=True)
    date = Column(Date, nullable=False)
    min_temp = Column(Float, nullable=False)
    max_temp = Column(Float, nullable=False)
    mean_temp = Column(Float, nullable=False)
    precipitation = Column(Float, nullable=False)
    city_id = Column(Integer, ForeignKey('cities.id'), nullable=False)

    city = relationship("City", back_populates="weather_entries")

    def to_dict(self):
        return {
            "id": self.id,
            "date": self.date,
            "min_temp": self.min_temp,
            "max_temp": self.max_temp,
            "mean_temp": self.mean_temp,
            "precipitation": self.precipitation,
            "city_id": self.city_id,
        }

    def __repr__(self):
        return (f"DailyWeatherEntry(id={self.id}, date='{self.date}', city_id={self.city_id}, "
                f"temperature_max={self.max_temp}, temperature_min={self.min_temp}, precipitation={self.precipitation})")


### File: E:/Users/Student/Documents/MSc/Python ICA1/CIS4044-N-ICA/ICA/src\models\__init__.py (Filename: __init__.py) ###

from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

from .city import City
from .country import Country
from .daily_weather_entry import DailyWeatherEntry

